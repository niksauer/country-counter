#!/usr/bin/env python3
"""
Script to plot visited countries on a world map.
Reads from the JSON output generated by count_countries.py
Uses coordinates from the locations array to infer states spatially.
"""

import argparse
import json
import sys
import warnings
from pathlib import Path

import geopandas as gpd
import matplotlib.pyplot as plt
from shapely.geometry import Point

# Suppress geopandas CRS warnings for centroid calculations
warnings.filterwarnings('ignore', message='.*geographic CRS.*centroid.*')


def load_countries_json(json_file: str) -> list[dict]:
    """
    Load countries from JSON file.

    Returns:
        list: List of country data dictionaries with 'country', 'count', and 'states' fields
    """
    with open(json_file, encoding='utf-8') as f:
        return json.load(f)


def plot_world_map(
    countries_data: list[dict],
    output_file: str | None = None,
    title: str = 'Visited Countries',
    show_labels: bool = False,
    color_full_country: bool = False,
    secondary_countries_data: list[dict] | None = None,
):
    """
    Plot countries on a world map.

    Args:
        countries_data: List of country data with 'country', 'count', and 'states' fields
        output_file: Path to save the output image (optional)
        title: Title for the map
        show_labels: If True, draw country names on the map and omit legends
        color_full_country: If True, color the entire country instead of individual states
        secondary_countries_data: Optional list of country data to plot at country level only (want to visit)
    """
    # Load world map data from Natural Earth
    world = gpd.read_file(
        'https://naciscdn.org/naturalearth/110m/cultural/ne_110m_admin_0_countries.zip'
    )

    # Create mapping of country names to handle variations
    country_mapping = {
        'United States': 'United States of America',
        'Dominican Republic': 'Dominican Rep.',
        'Czechia': 'Czech Rep.',
        'Tanzania': 'Tanzania',
    }

    # Separate countries into two groups: those with locations and those without
    countries_with_locations = {
        entry['country']: entry['locations']
        for entry in countries_data
        if entry.get('locations')
    }
    countries_without_locations = {
        entry['country'] for entry in countries_data if not entry.get('locations')
    }

    # Map country names for full-country highlighting
    mapped_countries_full = set()
    for country in countries_without_locations:
        mapped_countries_full.add(country_mapping.get(country, country))

    # Process secondary countries (want to visit)
    # Separate into: new countries (not in primary) and additional locations for existing countries
    secondary_countries = set()
    secondary_countries_with_locations = {}
    if secondary_countries_data:
        primary_countries = {entry['country'] for entry in countries_data}
        for entry in secondary_countries_data:
            country = entry['country']
            if country not in primary_countries:
                # New country - add to full country set
                mapped_country = country_mapping.get(country, country)
                secondary_countries.add(mapped_country)
            elif entry.get('locations') and not color_full_country:
                # Country already in primary with locations - collect for state-level processing
                secondary_countries_with_locations[country] = entry['locations']

    # If we have countries with locations, use coordinate-based state inference
    countries_to_plot_as_states = {}
    secondary_states_to_plot = {}  # Track secondary states separately for different coloring
    if (
        countries_with_locations or secondary_countries_with_locations
    ) and not color_full_country:
        # Load state/province boundaries from Natural Earth (10m resolution for better coverage)
        # This includes states/provinces for many countries including US, Canada, Australia, etc.
        print('Loading high-resolution state/province boundaries...')
        states_world = gpd.read_file(
            'https://naciscdn.org/naturalearth/10m/cultural/ne_10m_admin_1_states_provinces.zip'
        )
        available_country_names = sorted(states_world['admin'].unique())
        print(f'State-level data available for {len(available_country_names)} countries')
        print(
            f'Countries with state data: {", ".join(available_country_names[:10])}{"..." if len(available_country_names) > 10 else ""}'
        )

        # Get list of countries that have state boundaries available
        available_countries = set(states_world['admin'].unique())

        # Process primary countries with locations
        for country, locations in countries_with_locations.items():
            # Map country name to match Natural Earth dataset
            mapped_country = country_mapping.get(country, country)

            # Check if this country has state boundaries available
            if mapped_country in available_countries:
                # Infer states from coordinates using spatial containment
                matched_state_indices = set()

                for location in locations:
                    lat = location.get('lat')
                    lng = location.get('lng')

                    if lat is None or lng is None:
                        continue

                    # Create a point geometry from the coordinates
                    point = Point(lng, lat)

                    # Find which state(s) contain this point
                    # Filter to only states in this country
                    country_states = states_world[states_world['admin'] == mapped_country]

                    # Use spatial containment to find matching states
                    for idx, state_row in country_states.iterrows():
                        if state_row['geometry'].contains(point):  # pyright: ignore [reportAttributeAccessIssue]
                            matched_state_indices.add(idx)
                            break  # A point can only be in one state

                if matched_state_indices:
                    # Save for state-level plotting
                    countries_to_plot_as_states[mapped_country] = (
                        country,
                        matched_state_indices,
                    )
                    print(
                        f'  {country} ({mapped_country}): {len(matched_state_indices)} states inferred from {len(locations)} coordinates'
                    )
                else:
                    # No states matched, fall back to full country
                    print(
                        f'Warning: No states matched for {country} ({mapped_country}) from {len(locations)} coordinates'
                    )
                    mapped_countries_full.add(mapped_country)
            else:
                # Country not in states dataset, fall back to full country
                mapped_countries_full.add(mapped_country)

        # Process secondary countries with locations (only for countries already in primary with states)
        if secondary_countries_with_locations:
            print('\nProcessing secondary locations for existing countries...')
            for country, locations in secondary_countries_with_locations.items():
                mapped_country = country_mapping.get(country, country)

                # Only process if this country already has states from primary data
                if (
                    mapped_country in countries_to_plot_as_states
                    and mapped_country in available_countries
                ):
                    # Get the primary state indices to avoid duplicates
                    _, primary_state_indices = countries_to_plot_as_states[mapped_country]
                    matched_state_indices = set()

                    for location in locations:
                        lat = location.get('lat')
                        lng = location.get('lng')

                        if lat is None or lng is None:
                            continue

                        point = Point(lng, lat)
                        country_states = states_world[
                            states_world['admin'] == mapped_country
                        ]

                        for idx, state_row in country_states.iterrows():
                            if state_row['geometry'].contains(point):  # pyright: ignore [reportAttributeAccessIssue]
                                # Only add if not already in primary states
                                if idx not in primary_state_indices:
                                    matched_state_indices.add(idx)
                                break

                    if matched_state_indices:
                        secondary_states_to_plot[mapped_country] = matched_state_indices
                        print(
                            f'  {country} ({mapped_country}): {len(matched_state_indices)} additional states from secondary data'
                        )

        # Print summary of state-level highlighting
        if countries_to_plot_as_states:
            print(
                f'\nState-level highlighting for {len(countries_to_plot_as_states)} countries'
            )
    elif color_full_country:
        # If color_full_country is True, add all countries to full countries
        states_world = None
        for country in countries_with_locations:
            mapped_country = country_mapping.get(country, country)
            mapped_countries_full.add(mapped_country)
    else:
        states_world = None

    # Create a column for visited countries (only those being highlighted as full countries)
    world['visited'] = world['NAME'].isin(mapped_countries_full)  # pyright: ignore [reportArgumentType]

    # Create figure and axis with larger size for better legibility
    # Use explicit subplot parameters to ensure consistent canvas size
    fig, ax = plt.subplots(1, 1, figsize=(24, 12), subplot_kw={'adjustable': 'box'})
    fig.subplots_adjust(left=0.05, right=0.95, top=0.90, bottom=0.05)

    # Set ocean/background color
    ocean_color = '#d6e5f5'  # Light blue for ocean
    fig.patch.set_facecolor(ocean_color)
    ax.set_facecolor(ocean_color)

    # Generate unique colors for each country
    import matplotlib.colors as mcolors

    # Get all visited countries (both full and partial)
    all_visited_countries = sorted(
        set(mapped_countries_full) | set(countries_to_plot_as_states.keys())
        if countries_to_plot_as_states
        else mapped_countries_full
    )

    # Generate distinct colors using a colormap
    num_countries = len(all_visited_countries)
    # Use a qualitative colormap with many distinct colors
    cmap = plt.colormaps.get_cmap('tab20' if num_countries <= 20 else 'hsv')
    country_colors = {}
    for idx, country in enumerate(all_visited_countries):
        color = cmap(idx / max(num_countries - 1, 1))
        country_colors[country] = mcolors.to_hex(color)

    # Define a single color for secondary countries (want to visit)
    secondary_color = '#FFE5B4'  # Peach/light orange color

    # Create color mapping for the world map
    def get_country_color(name):
        if name in mapped_countries_full:
            return country_colors.get(name, '#f5f5f5')
        if name in secondary_countries:
            return secondary_color
        return '#f5f5f5'

    world['color'] = world['NAME'].apply(get_country_color)

    # Plot the base map with unique colors for each visited country
    world.plot(
        ax=ax,
        color=world['color'],
        edgecolor='#888888',  # Darker gray for borders
        linewidth=0.8,
    )

    # Plot states for countries with state-level data
    if countries_to_plot_as_states and states_world is not None:
        for mapped_country, (
            _original_country,
            state_indices,
        ) in countries_to_plot_as_states.items():
            # Filter states for this country using the matched indices
            country_states = states_world.loc[list(state_indices)]

            # Get the country's unique color and create a lighter version
            base_color = country_colors.get(mapped_country, '#999999')
            rgb = mcolors.hex2color(base_color)
            r, g, b = rgb[:3]
            light_color = mcolors.to_hex(
                (
                    min(1.0, r * 0.6 + 0.4),
                    min(1.0, g * 0.6 + 0.4),
                    min(1.0, b * 0.6 + 0.4),
                )
            )

            # Create a darker version of the base color for better contrast
            dark_color = mcolors.to_hex(
                (
                    r * 0.5,
                    g * 0.5,
                    b * 0.5,
                )
            )

            # Plot these specific states with lighter fill and darker border
            country_states.plot(
                ax=ax,
                facecolor=light_color,  # Lighter background
                edgecolor=dark_color,  # Darker border for better contrast
                linewidth=0.7,  # Thinner border to avoid overflow
            )

        # Plot secondary states (want to visit) with secondary color
        if secondary_states_to_plot:
            print('\nPlotting secondary states...')
            for state_indices in secondary_states_to_plot.values():
                country_states = states_world.loc[list(state_indices)]

                # Use the same secondary color as full countries
                rgb = mcolors.hex2color(secondary_color)
                r, g, b = rgb[:3]
                dark_secondary = mcolors.to_hex(
                    (
                        r * 0.7,
                        g * 0.7,
                        b * 0.7,
                    )
                )

                # Plot these secondary states with the same color as full secondary countries
                country_states.plot(
                    ax=ax,
                    facecolor=secondary_color,  # Use same color as full countries
                    edgecolor=dark_secondary,
                    linewidth=0.7,
                )

    # Remove axes
    ax.set_xlim(-180, 180)
    ax.set_ylim(-90, 90)
    ax.set_aspect('equal', adjustable='box')
    ax.axis('off')

    # Add title with better positioning
    plt.title(title, fontsize=28, pad=30, fontweight='bold', color='#333333')

    # Add legend with better styling
    from matplotlib.patches import Patch

    # Count countries and states
    num_full_countries = len(mapped_countries_full)
    num_state_countries = (
        len(countries_to_plot_as_states) if countries_to_plot_as_states else 0
    )
    total_states = (
        sum(
            len(state_indices)
            for _, state_indices in countries_to_plot_as_states.values()
        )
        if countries_to_plot_as_states
        else 0
    )
    num_secondary_countries = len(secondary_countries)
    num_secondary_states = (
        sum(len(state_indices) for state_indices in secondary_states_to_plot.values())
        if secondary_states_to_plot
        else 0
    )

    # First legend: General info (always shown)
    legend_elements = [
        Patch(
            facecolor='#999999',
            edgecolor='#888888',
            linewidth=1.5,
            label=f'Fully Visited: {num_full_countries} countries',
        ),
        Patch(
            facecolor='#cccccc',
            edgecolor='#999999',
            linewidth=1.5,
            label=f'Partially Visited: {num_state_countries} countries ({total_states} states)',
        ),
    ]

    # Add secondary countries legend if present
    if num_secondary_countries > 0 or num_secondary_states > 0:
        parts = []
        if num_secondary_countries > 0:
            parts.append(f'{num_secondary_countries} countries')
        if num_secondary_states > 0:
            parts.append(f'{num_secondary_states} states')
        label_text = f'Want to Visit: {", ".join(parts)}'
        legend_elements.append(
            Patch(
                facecolor=secondary_color,
                edgecolor='#888888',
                linewidth=1.5,
                label=label_text,
            )
        )

    legend_elements.append(
        Patch(
            facecolor='#f5f5f5',
            edgecolor='#888888',
            linewidth=1.5,
            label='Not Visited',
        )
    )
    legend1 = ax.legend(
        handles=legend_elements,
        loc='center',
        bbox_to_anchor=(0.25, 0.15),  # Position below Africa (left side)
        frameon=True,
        fancybox=True,
        shadow=True,
        fontsize=12,
        title='Overview',
        title_fontsize=14,
    )
    ax.add_artist(legend1)  # Add first legend to axes

    # Either show labels or country legend
    if show_labels:
        # Draw country names directly on the map (including secondary countries)
        all_labeled_countries = set(all_visited_countries) | secondary_countries
        for country in all_labeled_countries:
            # Get the country's geometry from the world dataset
            country_geom = world[world['NAME'] == country]
            if not country_geom.empty:
                # Get centroid for label placement
                centroid = country_geom.geometry.centroid.iloc[0]

                # Get the original country name
                original_name = country
                for orig, mapped in country_mapping.items():
                    if mapped == country:
                        original_name = orig
                        break

                # Draw the label
                ax.text(
                    centroid.x,
                    centroid.y,
                    original_name,
                    fontsize=5,
                    ha='center',
                    va='center',
                    fontweight='bold',
                    color='#333333',
                    bbox={
                        'boxstyle': 'round,pad=0.2',
                        'facecolor': 'white',
                        'edgecolor': '#888888',
                        'alpha': 0.8,
                        'linewidth': 0.3,
                    },
                )
    else:
        # Second legend: Country colors
        # Create legend entries for each country with its unique color
        country_legend_elements = []

        # Add full countries
        for country in sorted(mapped_countries_full):
            color = country_colors.get(country, '#999999')
            # Get the original country name (reverse mapping)
            original_name = country
            for orig, mapped in country_mapping.items():
                if mapped == country:
                    original_name = orig
                    break
            country_legend_elements.append(
                Patch(
                    facecolor=color,
                    edgecolor='#888888',
                    linewidth=0.5,
                    label=original_name,
                )
            )

        # Add state-level countries
        if countries_to_plot_as_states:
            for mapped_country, (
                original_country,
                _,
            ) in countries_to_plot_as_states.items():
                color = country_colors.get(mapped_country, '#999999')
                rgb = mcolors.hex2color(color)
                r, g, b = rgb[:3]
                light_color = mcolors.to_hex(
                    (
                        min(1.0, r * 0.6 + 0.4),
                        min(1.0, g * 0.6 + 0.4),
                        min(1.0, b * 0.6 + 0.4),
                    )
                )
                country_legend_elements.append(
                    Patch(
                        facecolor=light_color,
                        edgecolor=color,
                        linewidth=1.0,
                        label=original_country,
                    )
                )

        # Add secondary countries to the legend
        if secondary_countries:
            country_legend_elements.append(
                Patch(
                    facecolor=secondary_color,
                    edgecolor='#888888',
                    linewidth=0.5,
                    label='Want to Visit',
                )
            )

        ax.legend(
            handles=country_legend_elements,
            loc='center',
            bbox_to_anchor=(0.75, 0.15),
            frameon=True,
            fancybox=True,
            shadow=True,
            fontsize=10,
            title='Countries',
            title_fontsize=12,
            ncol=2 if len(country_legend_elements) > 15 else 1,
        )

    # Save or show with higher DPI for better quality
    if output_file:
        plt.savefig(
            output_file,
            dpi=300,
            facecolor=ocean_color,
            edgecolor='none',
            transparent=False,
        )
        print(f'Map saved to: {output_file}')
    else:
        plt.show()

    plt.close()


def main():
    parser = argparse.ArgumentParser(
        description='Plot visited countries on a world map from JSON output'
    )
    parser.add_argument(
        'json_file',
        help='Path to the countries JSON file (e.g., cache/Visited-Nik_countries.json)',
    )
    parser.add_argument(
        '--secondary-file',
        '-s',
        help='Path to a secondary countries JSON file for "want to visit" countries (plotted at country level only)',
    )
    parser.add_argument(
        '--output',
        '-o',
        help='Output file path. If not provided, saves to build/ directory with same name as input.',
    )
    parser.add_argument(
        '--title',
        default='Visited Countries',
        help='Title for the map (default: "Visited Countries")',
    )
    parser.add_argument(
        '--show-labels',
        action='store_true',
        help='Draw country names directly on the map instead of showing legends',
    )
    parser.add_argument(
        '--color-full-country',
        action='store_true',
        help='Color the entire country instead of individual states',
    )

    args = parser.parse_args()

    # Check if input file exists
    if not Path(args.json_file).exists():
        print(f'Error: JSON file "{args.json_file}" not found', file=sys.stderr)
        sys.exit(1)

    # Check if secondary file exists (if provided)
    if args.secondary_file and not Path(args.secondary_file).exists():
        print(
            f'Error: Secondary JSON file "{args.secondary_file}" not found',
            file=sys.stderr,
        )
        sys.exit(1)

    # Determine output file
    if args.output:
        output_file = args.output
    else:
        # Create build directory if it doesn't exist
        build_dir = Path('build')
        build_dir.mkdir(exist_ok=True)

        # Generate output filename based on input filename
        input_path = Path(args.json_file)
        output_filename = input_path.stem + '.svg'
        output_file = str(build_dir / output_filename)

    # Load countries
    print(f'Loading countries from {args.json_file}...')
    countries_data = load_countries_json(args.json_file)
    print(f'Found {len(countries_data)} countries')

    # Load secondary countries if provided
    secondary_countries_data = None
    if args.secondary_file:
        print(f'Loading secondary countries from {args.secondary_file}...')
        secondary_countries_data = load_countries_json(args.secondary_file)
        print(f'Found {len(secondary_countries_data)} secondary countries')

    # Plot map
    print('Generating map...')
    plot_world_map(
        countries_data,
        output_file=output_file,
        title=args.title,
        show_labels=args.show_labels,
        color_full_country=args.color_full_country,
        secondary_countries_data=secondary_countries_data,
    )

    print('Done!')


if __name__ == '__main__':
    main()
