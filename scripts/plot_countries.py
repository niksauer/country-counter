#!/usr/bin/env python3
"""
Script to plot visited countries on a world map.
Reads from the JSON output generated by count_countries.py
Uses coordinates from the locations array to infer states spatially.
"""

import argparse
import json
import sys
from pathlib import Path

import geopandas as gpd
import matplotlib.pyplot as plt
from shapely.geometry import Point


def load_countries_json(json_file: str) -> list[dict]:
    """
    Load countries from JSON file.

    Returns:
        list: List of country data dictionaries with 'country', 'count', and 'states' fields
    """
    with open(json_file, encoding='utf-8') as f:
        return json.load(f)


def plot_world_map(
    countries_data: list[dict],
    background_color: str = '#f0f0f0',
    visited_color: str = '#ff6b6b',
    output_file: str | None = None,
    title: str = 'Visited Countries',
):
    """
    Plot countries on a world map.

    Args:
        countries_data: List of country data with 'country', 'count', and 'states' fields
        background_color: Background color for the map
        visited_color: Color for visited countries
        output_file: Path to save the output image (optional)
        title: Title for the map
    """
    # Load world map data from Natural Earth
    world = gpd.read_file(
        'https://naciscdn.org/naturalearth/110m/cultural/ne_110m_admin_0_countries.zip'
    )

    # Create mapping of country names to handle variations
    country_mapping = {
        'United States': 'United States of America',
        'Dominican Republic': 'Dominican Rep.',
        'Czechia': 'Czech Rep.',
        'Tanzania': 'Tanzania',
    }

    # Separate countries into two groups: those with locations and those without
    countries_with_locations = {
        entry['country']: entry['locations']
        for entry in countries_data
        if entry.get('locations')
    }
    countries_without_locations = {
        entry['country'] for entry in countries_data if not entry.get('locations')
    }

    # Map country names for full-country highlighting
    mapped_countries_full = set()
    for country in countries_without_locations:
        mapped_countries_full.add(country_mapping.get(country, country))

    # If we have countries with locations, use coordinate-based state inference
    countries_to_plot_as_states = {}
    if countries_with_locations:
        # Load state/province boundaries from Natural Earth (10m resolution for better coverage)
        # This includes states/provinces for many countries including US, Canada, Australia, etc.
        print('Loading high-resolution state/province boundaries...')
        states_world = gpd.read_file(
            'https://naciscdn.org/naturalearth/10m/cultural/ne_10m_admin_1_states_provinces.zip'
        )
        available_country_names = sorted(states_world['admin'].unique())
        print(f'State-level data available for {len(available_country_names)} countries')
        print(
            f'Countries with state data: {", ".join(available_country_names[:10])}{"..." if len(available_country_names) > 10 else ""}'
        )

        # Get list of countries that have state boundaries available
        available_countries = set(states_world['admin'].unique())

        for country, locations in countries_with_locations.items():
            # Map country name to match Natural Earth dataset
            mapped_country = country_mapping.get(country, country)

            # Check if this country has state boundaries available
            if mapped_country in available_countries:
                # Infer states from coordinates using spatial containment
                matched_state_indices = set()

                for location in locations:
                    lat = location.get('lat')
                    lng = location.get('lng')

                    if lat is None or lng is None:
                        continue

                    # Create a point geometry from the coordinates
                    point = Point(lng, lat)

                    # Find which state(s) contain this point
                    # Filter to only states in this country
                    country_states = states_world[states_world['admin'] == mapped_country]

                    # Use spatial containment to find matching states
                    for idx, state_row in country_states.iterrows():
                        if state_row['geometry'].contains(point):  # pyright: ignore [reportAttributeAccessIssue]
                            matched_state_indices.add(idx)
                            break  # A point can only be in one state

                if matched_state_indices:
                    # Save for state-level plotting
                    countries_to_plot_as_states[mapped_country] = (
                        country,
                        matched_state_indices,
                    )
                    print(
                        f'  {country} ({mapped_country}): {len(matched_state_indices)} states inferred from {len(locations)} coordinates'
                    )
                else:
                    # No states matched, fall back to full country
                    print(
                        f'Warning: No states matched for {country} ({mapped_country}) from {len(locations)} coordinates'
                    )
                    mapped_countries_full.add(mapped_country)
            else:
                # Country not in states dataset, fall back to full country
                mapped_countries_full.add(mapped_country)

        # Print summary of state-level highlighting
        if countries_to_plot_as_states:
            print(
                f'\nState-level highlighting for {len(countries_to_plot_as_states)} countries'
            )
    else:
        states_world = None

    # Create a column for visited countries (only those being highlighted as full countries)
    world['visited'] = world['NAME'].isin(mapped_countries_full)  # pyright: ignore [reportArgumentType]

    # Create figure and axis
    fig, ax = plt.subplots(1, 1, figsize=(20, 10))
    fig.patch.set_facecolor(background_color)
    ax.set_facecolor(background_color)

    # Plot the base map (countries without specific states)
    world.plot(
        ax=ax,
        color=world['visited'].map({True: visited_color, False: '#e0e0e0'}),  # pyright: ignore [reportArgumentType]
        edgecolor='white',
        linewidth=0.5,
    )

    # Plot states for countries with state-level data
    if countries_to_plot_as_states and states_world is not None:
        for _original_country, state_indices in countries_to_plot_as_states.values():
            # Filter states for this country using the matched indices
            country_states = states_world.loc[list(state_indices)]

            # Plot these specific states with the visited color
            country_states.plot(
                ax=ax, color=visited_color, edgecolor='white', linewidth=0.5
            )

    # Remove axes
    ax.set_xlim(-180, 180)
    ax.set_ylim(-90, 90)
    ax.axis('off')

    # Add country labels for visited countries (full countries only)
    visited_countries = world[world['visited']]
    for _idx, row in visited_countries.iterrows():
        # Get the centroid of the country geometry
        centroid = row['geometry'].centroid  # pyright: ignore [reportAttributeAccessIssue]
        # Add text label at the centroid
        ax.text(
            centroid.x,
            centroid.y,
            row['NAME'],  # pyright: ignore [reportArgumentType]
            fontsize=6,
            ha='center',
            va='center',
            color='black',
            weight='bold',
            alpha=0.7,
        )

    # Add state labels for countries with state-level data
    if countries_to_plot_as_states and states_world is not None:
        for _original_country, state_indices in countries_to_plot_as_states.values():
            country_states = states_world.loc[list(state_indices)]
            for _idx, row in country_states.iterrows():
                centroid = row['geometry'].centroid
                ax.text(
                    centroid.x,
                    centroid.y,
                    row['name'],
                    fontsize=5,
                    ha='center',
                    va='center',
                    color='black',
                    weight='bold',
                    alpha=0.6,
                )

    # Add title
    plt.title(title, fontsize=24, pad=20, fontweight='bold')

    # Add legend
    from matplotlib.patches import Patch

    legend_elements = [
        Patch(facecolor=visited_color, label=f'Visited ({len(countries_data)})'),
        Patch(facecolor='#e0e0e0', label='Not visited'),
    ]
    ax.legend(
        handles=legend_elements,
        loc='lower left',
        frameon=True,
        fancybox=True,
        shadow=True,
    )

    plt.tight_layout()

    # Save or show
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches='tight', facecolor=background_color)
        print(f'Map saved to: {output_file}')
    else:
        plt.show()

    plt.close()


def main():
    parser = argparse.ArgumentParser(
        description='Plot visited countries on a world map from JSON output'
    )
    parser.add_argument(
        'json_file',
        help='Path to the countries JSON file (e.g., cache/Visited-Nik_countries.json)',
    )
    parser.add_argument(
        '--background-color',
        default='#f0f0f0',
        help='Background color for the map (default: #f0f0f0)',
    )
    parser.add_argument(
        '--visited-color',
        default='#ff6b6b',
        help='Color for visited countries (default: #ff6b6b)',
    )
    parser.add_argument(
        '--output',
        '-o',
        help='Output file path. If not provided, saves to build/ directory with same name as input.',
    )
    parser.add_argument(
        '--title',
        default='Visited Countries',
        help='Title for the map (default: "Visited Countries")',
    )

    args = parser.parse_args()

    # Check if input file exists
    if not Path(args.json_file).exists():
        print(f'Error: JSON file "{args.json_file}" not found', file=sys.stderr)
        sys.exit(1)

    # Determine output file
    if args.output:
        output_file = args.output
    else:
        # Create build directory if it doesn't exist
        build_dir = Path('build')
        build_dir.mkdir(exist_ok=True)

        # Generate output filename based on input filename
        input_path = Path(args.json_file)
        output_filename = input_path.stem + '.svg'
        output_file = str(build_dir / output_filename)

    # Load countries
    print(f'Loading countries from {args.json_file}...')
    countries_data = load_countries_json(args.json_file)
    print(f'Found {len(countries_data)} countries')

    # Plot map
    print('Generating map...')
    plot_world_map(
        countries_data,
        background_color=args.background_color,
        visited_color=args.visited_color,
        output_file=output_file,
        title=args.title,
    )

    print('Done!')


if __name__ == '__main__':
    main()
